<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Платформер с рекордом и плавной скоростью</title>
<style>
  html, body {
    margin: 0; 
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #87ceeb;
    overflow: hidden;
    flex-direction: column;
    font-family: Arial, sans-serif;
  }
  #game {
    background: #cceedd;
    display: block;
    width: 480px;
    height: 320px;
    max-width: 100vw;
    max-height: 80vh;
    border: 2px solid #333;
    display: none;
  }
  #jumpButton {
    margin-top: 15px;
    width: 120px;
    height: 50px;
    font-size: 24px;
    border-radius: 10px;
    background-color: #4CAF50;
    color: white;
    border: none;
    user-select: none;
    touch-action: manipulation;
    display: none;
  }
  #jumpButton:active {
    background-color: #388E3C;
  }
  #menu {
    color: #fff;
    text-align: center;
  }
  #menu button {
    padding: 15px 30px;
    font-size: 24px;
    border-radius: 10px;
    border: none;
    background-color: #4CAF50;
    color: white;
    cursor: pointer;
    user-select: none;
    touch-action: manipulation;
  }
  #menu button:active {
    background-color: #388E3C;
  }
</style>
</head>
<body>

<div id="menu">
  <h1>Бесконечный платформер</h1>
  <button id="startButton">Начать игру</button>
</div>

<canvas id="game"></canvas>
<button id="jumpButton">Прыжок</button>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const menu = document.getElementById('menu');
const startButton = document.getElementById('startButton');
const jumpButton = document.getElementById('jumpButton');

canvas.width = 480;
canvas.height = 320;

const gravity = 0.6;

let gameRunning = false;
let jumpRequested = false;

let score = 0;
let highScore = localStorage.getItem('highScore') || 0;

class Player {
  constructor() {
    this.width = 30;
    this.height = 50;
    this.x = 50;
    this.y = canvas.height - this.height - 30;
    this.dy = 0;
    this.jumpForce = -12;
    this.grounded = false;
  }
  
  update() {
    this.dy += gravity;
    this.y += this.dy;
  }
  
  draw() {
    ctx.fillStyle = 'red';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

class Platform {
  constructor(x, y, width=100, height=15) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  
  update(speed) {
    this.x -= speed;
  }
  
  draw() {
    ctx.fillStyle = 'green';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

class Spike {
  constructor(x, y, size=20) {
    this.x = x;
    this.y = y;
    this.size = size;
  }
  
  update(speed) {
    this.x -= speed;
  }
  
  draw() {
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + this.size / 2, this.y - this.size);
    ctx.lineTo(this.x + this.size, this.y);
    ctx.closePath();
    ctx.fill();
  }
  
  collide(player) {
    let spikeRect = {
      x: this.x,
      y: this.y - this.size,
      width: this.size,
      height: this.size
    };
    
    let playerRect = {
      x: player.x,
      y: player.y,
      width: player.width,
      height: player.height
    };
    
    return !(playerRect.x > spikeRect.x + spikeRect.width ||
             playerRect.x + playerRect.width < spikeRect.x ||
             playerRect.y > spikeRect.y + spikeRect.height ||
             playerRect.y + playerRect.height < spikeRect.y);
  }
}

const player = new Player();
let platforms = [];
let spikes = [];
let platformSpeed = 3;
let frameCount = 0;
let lastTime = 0;

function resetGame() {
  player.y = canvas.height - player.height - 30;
  player.dy = 0;
  player.grounded = false;
  platforms = [];
  spikes = [];
  frameCount = 0;
  score = 0;

  platforms.push(new Platform(0, canvas.height - 30, canvas.width, 30));
  
  for(let i = 200; i < canvas.width; i += 140) {
    spikes.push(new Spike(i, canvas.height - 30));
  }
}

function collision(player, platform) {
  const horizontalCollision = player.x + player.width > platform.x && player.x < platform.x + platform.width;
  const verticalCollision = player.y + player.height >= platform.y && player.y + player.height <= platform.y + 10;
  return horizontalCollision && verticalCollision;
}

function gameLoop(time=0) {
  if (!gameRunning) return;

  const deltaTime = (time - lastTime) / 16.67;
  lastTime = time;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  frameCount++;

  score++;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('highScore', highScore);
  }

  let lastPlatform = platforms.length > 0 ? platforms[platforms.length - 1] : null;
  if (!lastPlatform || lastPlatform.x + lastPlatform.width < canvas.width - 150) {
    let platformHeight = canvas.height - 30 - Math.random() * 80;
    platforms.push(new Platform(canvas.width, platformHeight));
  }

  const speed = platformSpeed * deltaTime;

  for(let i = platforms.length -1; i >= 0; i--) {
    platforms[i].update(speed);
    platforms[i].draw();

    if(platforms[i].x + platforms[i].width < 0) {
      platforms.splice(i, 1);
    }
  }
  
  let lastSpike = spikes.length > 0 ? spikes[spikes.length - 1] : null;
  if (!lastSpike || lastSpike.x < canvas.width - 140) {
    spikes.push(new Spike(canvas.width, canvas.height - 30));
  }

  for(let i = spikes.length -1; i >= 0; i--) {
    spikes[i].update(speed);
    spikes[i].draw();

    if(spikes[i].x + spikes[i].size < 0) {
      spikes.splice(i, 1);
    }

    if(spikes[i].collide(player)) {
      gameRunning = false;
      showMenu();
      return;
    }
  }

  player.grounded = false;

  for(let platform of platforms) {
    if(collision(player, platform)) {
      player.y = platform.y - player.height;
      player.dy = 0;
      player.grounded = true;
      break;
    }
  }

  if(player.y + player.height >= canvas.height - 30) {
    player.y = canvas.height - 30 - player.height;
    player.dy = 0;
    player.grounded = true;
  }

  if (jumpRequested && player.grounded) {
    player.dy = -12;
    player.grounded = false;
  }
  jumpRequested = false;

  player.update();
  player.draw();

  ctx.fillStyle = '#654321';
  let groundWidth = 40;
  let offset = (frameCount * platformSpeed) % groundWidth;
  for(let x = -offset; x < canvas.width; x += groundWidth) {
    ctx.fillRect(x, canvas.height - 30, groundWidth / 2, 30);
  }

  ctx.fillStyle = 'black';
  ctx.font = '20px Arial';
  ctx.fillText(Счёт: ${score}, 10, 25);
  ctx.fillText(Рекорд: ${highScore}, 10, 50);

  requestAnimationFrame(gameLoop);
}

window.addEventListener('keydown', (e) => {
  if(e.code === 'Space' && gameRunning) {
    jumpRequested = true;
  }
});

jumpButton.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if(gameRunning) jumpRequested = true;
});
jumpButton.addEventListener('mousedown', (e) => {
  e.preventDefault();
  if(gameRunning) jumpRequested = true;
});

startButton.addEventListener('click', () => {
  lastTime = 0;   // сброс таймера
  startGame();
});

function showMenu() {
  menu.style.display = 'block';
  canvas.style.display = 'none';
  jumpButton.style.display = 'none';
}

function startGame() {
  menu.style.display = 'none';
  canvas.style.display = 'block';
  jumpButton.style.display = 'inline-block';
  resetGame();
  gameRunning = true;
  requestAnimationFrame(gameLoop);
}

showMenu();
</script>
</body>
</html>
