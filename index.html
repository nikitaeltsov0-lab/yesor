<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Бесконечный платформер с шипами</title>
<style>
  html, body {
    margin: 0; 
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #87ceeb;
    overflow: hidden;
    flex-direction: column;
  }
  #game {
    background: #cceedd;
    display: block;
    width: 480px;
    height: 320px;
    max-width: 100vw;
    max-height: 80vh;
    border: 2px solid #333;
  }
  #jumpButton {
    margin-top: 15px;
    width: 120px;
    height: 50px;
    font-size: 24px;
    border-radius: 10px;
    background-color: #4CAF50;
    color: white;
    border: none;
    user-select: none;
    touch-action: manipulation;
  }
  #jumpButton:active {
    background-color: #388E3C;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<button id="jumpButton">Прыжок</button>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

canvas.width = 480;
canvas.height = 320;

const gravity = 0.6;

class Player {
  constructor() {
    this.width = 30;
    this.height = 50;
    this.x = 50;
    this.y = canvas.height - this.height - 30; // старт на полу
    this.dy = 0;
    this.jumpForce = -12;
    this.grounded = false;
  }
  
  update() {
    this.dy += gravity;
    this.y += this.dy;
    
    // Столкновение с полом
    if(this.y + this.height > canvas.height - 30) {
      this.y = canvas.height - 30 - this.height;
      this.dy = 0;
      this.grounded = true;
    } else {
      this.grounded = false;
    }
  }
  
  jump() {
    if(this.grounded) {
      this.dy = this.jumpForce;
      this.grounded = false;
    }
  }
  
  draw() {
    ctx.fillStyle = 'red';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

class Platform {
  constructor(x, y, width=100, height=15) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  
  update(speed) {
    this.x -= speed;
  }
  
  draw() {
    ctx.fillStyle = 'green';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

class Spike {
  constructor(x, y, size=20) {
    this.x = x;
    this.y = y;
    this.size = size;
  }
  
  update(speed) {
    this.x -= speed;
  }
  
  draw() {
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.moveTo(this.x, this.y);
    ctx.lineTo(this.x + this.size / 2, this.y - this.size);
    ctx.lineTo(this.x + this.size, this.y);
    ctx.closePath();
    ctx.fill();
  }
  
  collide(player) {
    // Простая проверка пересечения прямоугольников (спайк - bbox)
    let spikeRect = {
      x: this.x,
      y: this.y - this.size,
      width: this.size,
      height: this.size
    };
    
    let playerRect = {
      x: player.x,
      y: player.y,
      width: player.width,
      height: player.height
    };
    
    return !(playerRect.x > spikeRect.x + spikeRect.width ||
             playerRect.x + playerRect.width < spikeRect.x ||
             playerRect.y > spikeRect.y + spikeRect.height ||
             playerRect.y + playerRect.height < spikeRect.y);
  }
}

const player = new Player();
let platforms = [];
let spikes = [];
let platformSpeed = 3;
let frameCount = 0;

function resetGame() {
  player.x = 50;
  player.y = canvas.height - player.height - 30;
  player.dy = 0;
  player.grounded = false;
  platforms = [];
  spikes = [];
  frameCount = 0;
  
  // Стартовая платформа (пол)
  platforms.push(new Platform(0, canvas.height - 30, canvas.width, 30));
  
  // Шипы на полу, равномерно
  for(let i = 100; i < canvas.width; i += 80) {
    spikes.push(new Spike(i, canvas.height - 30));
  }
}

function collision(player, platform) {
  // Проверка, что игрок сверху платформы, и немного учитываем движение вниз (dy)
  return player.x < platform.x + platform.width &&
         player.x + player.width > platform.x &&
         player.y + player.height <= platform.y + player.dy &&
         player.y + player.height + player.dy >= platform.y;
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  frameCount++;

// Добавляем платформы каждые 80 кадров (~2.5 секунды)
  if(frameCount % 80 === 0) {
    let platformHeight = canvas.height - 30 - Math.random() * 80;
    platforms.push(new Platform(canvas.width, platformHeight));
  }

  for(let i = platforms.length -1; i >= 0; i--) {
    platforms[i].update(platformSpeed);
    platforms[i].draw();

    if(platforms[i].x + platforms[i].width < 0) {
      platforms.splice(i, 1);
    }
  }
  
  // Шипы обновляем и рисуем
  for(let i = spikes.length -1; i >= 0; i--) {
    spikes[i].update(platformSpeed);
    spikes[i].draw();

    if(spikes[i].x + spikes[i].size < 0) {
      spikes.splice(i, 1);
    }

    if(spikes[i].collide(player)) {
      // При столкновении со шипами — рестарт игры
      resetGame();
      return;
    }
  }

  // Обработка столкновения игрока с платформами
  player.grounded = false;
  for(let platform of platforms) {
    if(collision(player, platform)) {
      player.y = platform.y - player.height;
      player.dy = 0;
      player.grounded = true;
      break;
    }
  }

  player.update();
  player.draw();

  requestAnimationFrame(gameLoop);
}

window.addEventListener('keydown', (e) => {
  if(e.code === 'Space') {
    player.jump();
  }
});

const jumpButton = document.getElementById('jumpButton');
jumpButton.addEventListener('touchstart', (e) => {
  e.preventDefault();
  player.jump();
});
jumpButton.addEventListener('mousedown', (e) => {
  e.preventDefault();
  player.jump();
});

// Запуск игры
resetGame();
gameLoop();
</script>
</body>
</html>
